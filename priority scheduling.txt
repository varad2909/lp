#include <iostream>
#include <algorithm>
#include <iomanip>
using namespace std;

struct Process {
    int id;
    int burst_time;
    int arrival_time;
    int priority;
    int waiting_time;
    int completion_time;
    int turn_around_time;
};

// Sort by arrival time first
bool compareArrival(const Process &a, const Process &b) {
    return a.arrival_time < b.arrival_time;
}

// Sort by priority (lower value = higher priority)
bool comparePriority(const Process &a, const Process &b) {
    return a.priority < b.priority;
}

int main() {
    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    Process P[20];

    cout << "Enter Process IDs: ";
    for (int i = 0; i < n; i++)
        cin >> P[i].id;

    cout << "Enter Burst Times: ";
    for (int i = 0; i < n; i++)
        cin >> P[i].burst_time;

    cout << "Enter Arrival Times: ";
    for (int i = 0; i < n; i++)
        cin >> P[i].arrival_time;

    cout << "Enter Priorities (lower = higher priority): ";
    for (int i = 0; i < n; i++)
        cin >> P[i].priority;

    // Sort by arrival time first
    sort(P, P + n, compareArrival);

    int time = 0;
    bool completed[20] = {false};
    int completedCount = 0;
    double total_wt = 0, total_tat = 0;

    cout << "\n===== Priority Scheduling Simulation =====\n";

    while (completedCount < n) {
        int idx = -1;
        int highest_priority = 1e9;

        for (int i = 0; i < n; i++) {
            if (!completed[i] && P[i].arrival_time <= time) {
                if (P[i].priority < highest_priority) {
                    highest_priority = P[i].priority;
                    idx = i;
                }
            }
        }

        if (idx != -1) {
            time += P[idx].burst_time;
            P[idx].completion_time = time;
            P[idx].turn_around_time = P[idx].completion_time - P[idx].arrival_time;
            P[idx].waiting_time = P[idx].turn_around_time - P[idx].burst_time;

            total_wt += P[idx].waiting_time;
            total_tat += P[idx].turn_around_time;
            completed[idx] = true;
            completedCount++;
        } else {
            time++; // If no process has arrived yet, move time forward
        }
    }

    // Display table
    cout << "\n==============================================\n";
    cout << "PID\tAT\tBT\tPR\tCT\tTAT\tWT\n";
    cout << "==============================================\n";

    for (int i = 0; i < n; i++) {
        cout << P[i].id << "\t"
             << P[i].arrival_time << "\t"
             << P[i].burst_time << "\t"
             << P[i].priority << "\t"
             << P[i].completion_time << "\t"
             << P[i].turn_around_time << "\t"
             << P[i].waiting_time << endl;
    }

    cout << "==============================================\n";
    cout << fixed << setprecision(2);
    cout << "Average Turnaround Time: " << (total_tat / n) << endl;
    cout << "Average Waiting Time:    " << (total_wt / n) << endl;

    return 0;
}


/*sample input:-
		Enter number of processes: 4
Enter Process IDs: 1 2 3 4
Enter Burst Times: 5 3 8 6
Enter Arrival Times: 0 1 2 3
Enter Priorities (lower = higher priority): 2 1 4 3
*/

/*sample output:-
		===== Priority Scheduling Simulation =====

==============================================
PID	AT	BT	PR	CT	TAT	WT
==============================================
1	0	5	2	5	5	0
2	1	3	1	8	7	4
4	3	6	3	14	11	5
3	2	8	4	22	20	12
==============================================
Average Turnaround Time: 10.75
Average Waiting Time:    5.25*/